# Checking pixel logic
# check from rightest to the left to see if there is a green or red candle


#### Pending: 
Minute photo cap logic 


Steps:
1. Run extract_hex_colors.py to find the matched color.
2. Input the matched color then run search_specific_color.py, to check whenther the color is right or not.



### run strategy.py to start the strategy


### add the zigzag indicator 

#Steps:
1. Open scrape.py, open NVDA, TSLA etc.
2. 每5 min 整分鐘 - 30s 就refresh all tabs, then > 5分鐘整就 capture all tabs photos.
3. Save the photo in a proper dir, open ${number of photo captured} threading.
3. Input the photo for the strategy, output the signal.


??? 跟PID or what?
### alert -done
### logging -done
### close tab then reopen again at 5-30s... not refresh only
### auto start logic.
### all three - > 1.0 confidence buy
### only two -> 0.5 confidence to buy (zigzag + ???)
#### only open new tabs -30s, and then refresh only at 00.


## not enought candle i.e. image width too short.
***** 問號，係咪indicator 會update 快過 00整點即refresh一次之後再cap
***** 問號 90 pixel too long? Maybe can set shorter (AB=CD is 90pixel, but the longer then easier to reach)
### Check the time for checking the 賣吾賣order 耐吾耐

***** check the program 有冇bug
*** 10 tabs, 要令到last two no delay


### fabaci too big, chcek the stop loss and take profit. - done
### daily close having problem - done





## main_with_ib_trading_2.py
Now I want a new logic of the "get_current_price", it will be a atomic function for getting the price from a global dictionary. And now there will be a new thread which keeps updating the current price concurrent to the global dictionary, the reference code:"""
from ibapi.client import EClient
from ibapi.wrapper import EWrapper
from ibapi.contract import Contract

import threading
import time


class IBapi(EWrapper, EClient):
	def __init__(self):
		EClient.__init__(self, self)
		self.reqId_to_symbol = {}
	def tickPrice(self, reqId, tickType, price, attrib):
		if tickType == 4:
			symbol = self.reqId_to_symbol.get(reqId, str(reqId))
			print(f"{symbol} last price: {price}")

def run_loop():
	app.run()

app = IBapi()
app.connect('127.0.0.1', 4002, 123)

#Start the socket in a thread
api_thread = threading.Thread(target=run_loop, daemon=True)
api_thread.start()

time.sleep(0.1) #Sleep interval to allow time for connection to server

# Request market data for multiple symbols concurrently
def request_market_data(req_id, symbol):
	contract = Contract()
	contract.symbol = symbol
	contract.secType = 'STK'
	contract.exchange = 'SMART'
	contract.currency = 'USD'
	app.reqId_to_symbol[req_id] = symbol
	app.reqMktData(req_id, contract, '', False, False, [])

symbols = ['NVDA', 'AAPL', 'TSLA',"QQQ","NIO"]
threads = []
for idx, sym in enumerate(symbols, start=1):
	t = threading.Thread(target=request_market_data, args=(idx, sym), daemon=True)
	threads.append(t)
	t.start()

time.sleep(10) #Sleep interval to allow time for incoming price data
app.disconnect()
"""
### Notes: the symbols = $stock_list

I hope this can keep the connection to ib more properly.
New logic -> start a pool of keep getting the current price.